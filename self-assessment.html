<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Professional Self-Assessment – CS-499</title>
  <meta name="description" content="Professional self-assessment introducing the ePortfolio and summarizing strengths across collaboration, communication, algorithms/DS, software engineering, databases, and security." />
  <link rel="stylesheet" href="/assets/css/style.css" />
</head>
<body>
<header class="site-header">
  <nav class="nav">
    <a class="brand" href="/">Merrik Wright</a>
    <a class="active" href="/self-assessment.html">Self-Assessment</a>
    <a href="/artifacts/travlr.html">TRAVLR Artifact</a>
    <a href="/code-review.html">Code Review</a>
  </nav>
</header>

<main class="container">
  <h1>Professional Self-Assessment</h1>

  <p><em>Overview</em> — This ePortfolio introduces my capstone work, demonstrating growth in software design/engineering, algorithms and data structures, databases, and security, with clear communication and UI/UX.</p>

  <h2>Strengths & Evidence</h2>
  <p><strong>Collaboration & Stakeholder Communication.</strong> During the TRAVLR enhancement cycle I treated the “site admin” persona as my primary stakeholder and managed the work in short, reviewable iterations. I opened small GitHub issues for each change (encryption utility, account-settings API, schema update) and created branch-scoped pull requests with checklists. After each slice, I recorded a short code-review walkthrough and summarized decisions in the PR description (what changed, why it changed, risks, and rollback plan). Review feedback led to concrete improvements: separating crypto from route handlers, documenting environment variables, replacing ad-hoc error strings with a consistent error shape, and wrapping all async bcrypt paths in try/catch with explicit early returns.</p>

<p>Peer and instructor-style reviews shaped naming, structure, and communication. For example, a comment thread on the settings update flow prompted me to remove duplicate validation logic from two routes and expose a single “validateSettings” helper, add JSDoc comments for public functions, and standardize HTTP status codes and error messages. I also posted brief stakeholder notes after each iteration (change summary, impact, and next step), which made decisions traceable and kept the “stakeholder” focus on value: safer login, clearer settings UX, and maintainable code the next developer can pick up quickly.</p>

  <p><strong>Algorithms & Data Structures; Software Engineering & Databases.</strong> Algorithmic thinking showed up most in the authentication and settings flows. I reworked the login path to validate inputs up front, short-circuit on failures, and rely on indexed, single-document lookups (unique index on username/email) rather than any list scans. The compare step uses bcrypt’s constant-time comparison, and I consolidated duplicate checks into a single validator so the “happy path” stays narrow and predictable. I also reduced DB round-trips by projecting only the fields the route needs and by normalizing settings data so the update operation is a single atomic write. These changes simplify control flow, reduce error surface, and make performance behavior easier to reason about.</p>

<p>On the engineering side, I moved cryptographic operations into a dedicated module (<code>util/encryption.js</code>) to respect single-responsibility and make testing easier. Route handlers now call small service-style helpers that do one thing well (authenticate, sanitize, encrypt/decrypt, persist). I added consistent error handling and input validation helpers, which removed repeated code and lowered complexity. For the database, I extended the user schema to include settings with defaults and constraints, and I wrote a simple migration routine to backfill existing documents safely. I verified changes with smoke tests (manual API calls/collections) for register → login → update settings → re-login, plus negative tests for invalid payloads and duplicate usernames. Net effect: fewer code paths, clearer boundaries, safer writes, and faster, more predictable I/O.</p>

 <p><strong>Security Mindset.</strong> Security guided every enhancement. Credentials are never stored reversibly; I use salted <code>bcrypt</code> hashing for passwords and reserve AES encryption for data that must be reversible. All inputs pass through a validation layer (type, length, allowed values), and handlers only whitelist fields that can be written—preventing privilege escalation via unexpected attributes. Errors are generic to avoid user enumeration, secrets live in environment variables (not in the repo), and logs intentionally exclude sensitive data. Database updates run with least-privilege assumptions (update only the specific user’s document, project only needed fields), and I avoided leaking internal structure through responses. These practices, reinforced by secure-coding coursework, produced an implementation that is resilient to common risks while remaining maintainable.</p>

  <h2>How the Artifacts Fit Together</h2>
  <p>TRAVLR is the central artifact. The enhancements span software design (encryption module, modular account settings), algorithms/DS (secure authentication flow; validation logic), and databases (MongoDB schema updates, CRUD for settings). The portfolio pages map each enhancement to course outcomes and include a code-review video to contextualize decisions.</p>

  <p class="note">Tip: keep paragraphs short and scannable; use concrete examples and numbers where possible.</p>
</main>

<footer class="site-footer">
  <small>© <span id="y"></span> Merrik Wright</small>
</footer>
<script>
  document.getElementById('y').textContent = new Date().getFullYear();
  for (const a of document.querySelectorAll('a[href^="http"]')) {
    if (a.host !== location.host) { a.target = "_blank"; a.rel = "noopener"; }
  }
</script>
</body>
</html>
